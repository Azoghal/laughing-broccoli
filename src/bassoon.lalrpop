use std::str::FromStr;
use crate::ast::{ASTStatement, CondBlock, Expr, BinOpcode, PfxOpcode, SfxOpcode};
use lalrpop_util::ErrorRecovery; // Also needed for getting more than one error
use lalrpop_util::ParseError;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, &'static str>>); 

// TODO add strings?
match{
    // r"[0-9]+\.[0-9]*" => Float,
    r"[0-9]+" => Int,
}else{
    r"\w+" => Id,
    _ // Includes all our keywords - as they are string literals they will be matched first
}

pub Statements: Vec<Box<ASTStatement>> = {
    Statement*
};

pub CodeBlock: Box<ASTStatement> = {
    "{" <Statements> "}" => Box::new(ASTStatement::CodeBlock(<>))
}

pub Statement: Box<ASTStatement> = {
    <Stmnt> ";"
};

// TODO replace "=" with generic opcode?
// TODO replace Statement::Assign with e.g. action 
// TODO make if a named keyword?
// TODO make mutliple, simpler if boys.
Stmnt: Box<ASTStatement> = {
    <id:Id> "=" <e:Expr> => Box::new(ASTStatement::Assign(id.into(), e)),
    "if" <Expr> <CodeBlock> => Box::new(ASTStatement::If(CondBlock(<>), None, None)),
    "if" <ic:Expr> <iw:CodeBlock> "else if" <ei:(<Expr> <CodeBlock>)> => {
        let icb = CondBlock(ic, iw);
        let (eic, eiw) = ei;
        let eicb = CondBlock(eic, eiw);
        Box::new(ASTStatement::If(icb, Some(vec![eicb]), None))
    },
    // "if" <i:(<Expr> <CodeBlock>)> <elifs:(("else if" <Expr> <CodeBlock>)*)?> <el:("else" <CodeBlock>)?>  => {
    //     icb: = CondBlock(i);
    //     elifcbs = elifs.map(|elif| CondBlock(elif));
    //     Box::new(ASTStatement::If(icb, elifcbs, el))
    // }
};

Tier<Op, NextTier>: Box<Expr> = {
    Tier<Op, NextTier> Op NextTier => Box::new(Expr::BinOp(<>)),
    NextTier,
};

// Unary binds most tightly, +- most loosely
pub Expr = Tier<ExprOp, Factor>;
Factor = Tier<FactorOp, SfxUnary>;
SfxUnary: Box<Expr> = {
    SfxUnary SfxOp => Box::new(Expr::SfxUnOp(<>)),
    PfxUnary,
};
PfxUnary: Box<Expr> = {
    PfxOp PfxUnary => Box::new(Expr::PfxUnOp(<>)),
    Term,
}


ExprOp: BinOpcode = { 
    "+" => BinOpcode::Add,
    "-" => BinOpcode::Sub,
};

FactorOp: BinOpcode = {
    "*" => BinOpcode::Mul,
    "/" => BinOpcode::Div,
};

// TODO add minus
PfxOp: PfxOpcode = {
    "!" => PfxOpcode::Not,
};

SfxOp: SfxOpcode = {
    "!" => SfxOpcode::Fact,
};

Term: Box<Expr> = {
    Num => Box::new(Expr::Number(<>)),
    Lit => Box::new(Expr::Literal(<>)),
    "(" <Expr> ")",
    ! => {errors.push(<>); Box::new(Expr::Error)}, 
};

// TODO work out - is it possible to put these errors into errors as well?
Num: i32 = {
    Int =>? i32::from_str(<>).map_err(|_| ParseError::User{
        error: "bob done make an number demasiado grande"
    })
};

Lit: String = {
    <l:r#""[a-z ]*""#> => l[1..l.len()-1].into()
};