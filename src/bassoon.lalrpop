use std::str::FromStr;
use crate::ast::{ASTStatement, ASTType, CondBlock, Expr, BinOpcode, PfxOpcode, SfxOpcode};
use lalrpop_util::ErrorRecovery; // Also needed for getting more than one error
use lalrpop_util::ParseError;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, &'static str>>); 

// TODO add strings?
match{
    // r"[0-9]+\.[0-9]*" => Float,
    r"[0-9]+" => Int,
    "if",
    "else",
    "while",
    "for",
    "define",
    "gives",
    "as",
    "int",
    "float",
}else{
    r"\w+" => Id,
    _ // Includes all our keywords - as they are string literals they will be matched first
}

pub Statements: Vec<Box<ASTStatement>> = {
    Statement*
};

pub CodeBlock: Box<ASTStatement> = {
    "{" <Statements> "}" => Box::new(ASTStatement::CodeBlock(<>))
}

pub Statement: Box<ASTStatement> = {
    <Stmnt> ";",
    "if" <ic:Expr> <iw:CodeBlock> <eis: ("else if" <Expr> <CodeBlock>)*> <ecb:("else" <CodeBlock>)?> => {
        let icb = CondBlock(ic, iw);
        let ei_cbs = eis.into_iter().map(|(e,w)| CondBlock(e,w)).collect();  // TODO can this just use condblock as a function rather than using in a closure
        Box::new(ASTStatement::If(icb, ei_cbs, ecb))
    },
    "while" <Expr> <CodeBlock> => Box::new(ASTStatement::While(<>)),
    "for" "(" <Stmnt> ";" <Expr> ";" <Stmnt> ")" <CodeBlock> => Box::new(ASTStatement::For(<>))
};

// TODO replace "=" with generic opcode?
// TODO replace Statement::Assign with e.g. action 
// TODO make if a named keyword?
// TODO make mutliple, simpler if boys.
Stmnt: Box<ASTStatement> = {
    <id:Id> "=" <e:Expr> => Box::new(ASTStatement::Assign(id.into(), e)),
    // <id:Id> "of" <t:Type> "=" <e:Expr> => Box::new(ASTStatement::Intlstn(id.into(),))
};

Tier<Op, NextTier>: Box<Expr> = {
    Tier<Op, NextTier> Op NextTier => Box::new(Expr::BinOp(<>)),
    NextTier,
};

// Unary binds most tightly, +- most loosely
pub Expr = Tier<BoolOp, Arith>;
Arith = Tier<ArithOp, Factor>;
Factor = Tier<FactorOp, SfxUnary>;
SfxUnary: Box<Expr> = {
    SfxUnary SfxOp => Box::new(Expr::SfxUnOp(<>)),
    PfxUnary,
};
PfxUnary: Box<Expr> = {
    PfxOp PfxUnary => Box::new(Expr::PfxUnOp(<>)),
    Term,
}

BoolOp: BinOpcode = {
    ">" => BinOpcode::GreaterThan,
    "<" => BinOpcode::LessThan
}

ArithOp: BinOpcode = { 
    "+" => BinOpcode::Add,
    "-" => BinOpcode::Sub,
};

FactorOp: BinOpcode = {
    "*" => BinOpcode::Mul,
    "/" => BinOpcode::Div,
};

// TODO add minus
PfxOp: PfxOpcode = {
    "!" => PfxOpcode::Not,
    "-" => PfxOpcode::Minus
};

SfxOp: SfxOpcode = {
    "!" => SfxOpcode::Fact,
};

Term: Box<Expr> = {
    Num => Box::new(Expr::Number(<>)),
    Lit => Box::new(Expr::Literal(<>)),
    Id => Box::new(Expr::Id(<>.to_string())),
    "(" <Expr> ")",
    ! => {errors.push(<>); Box::new(Expr::Error)}, 
};

// TODO work out - is it possible to put these errors into errors as well?
Num: i32 = {
    Int =>? i32::from_str(<>).map_err(|_| ParseError::User{
        error: "bob done make an number demasiado grande"
    })
};

Lit: String = {
    <l:r#""[a-z ]*""#> => l[1..l.len()-1].into()
};

pub Type: Box<ASTType> = {
    "int" => Box::new(ASTType::Int),
    "float" => Box::new(ASTType::Float),
    Id => Box::new(ASTType::Custom(<>.to_string()))
};